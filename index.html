<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <title>Log temperatury z QR</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 20px;
      background: #f5f5f5;
    }
    h1 {
      font-size: 1.4rem;
      margin-bottom: 0.3rem;
    }
    h2 {
      font-size: 1.1rem;
      margin-top: 1.2rem;
    }
    .card {
      background: #ffffff;
      border-radius: 8px;
      padding: 16px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.08);
      margin-bottom: 16px;
    }
    .info-row {
      margin: 4px 0;
    }
    .info-label {
      font-weight: 600;
    }
    .error {
      color: #b00020;
      font-weight: 600;
      margin-top: 8px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 8px;
      background: #fff;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 6px 8px;
      text-align: center;
      font-size: 0.9rem;
    }
    th {
      background: #f0f0f0;
      font-weight: 600;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      margin-top: 8px;
    }
    .controls input[type="text"] {
      flex: 1 1 260px;
      padding: 6px 8px;
      border-radius: 4px;
      border: 1px solid #ccc;
      font-family: monospace;
      font-size: 0.85rem;
    }
    button {
      padding: 6px 12px;
      border-radius: 4px;
      border: none;
      background: #1976d2;
      color: white;
      cursor: pointer;
      font-size: 0.9rem;
    }
    button:hover {
      background: #125ca4;
    }
    .small {
      font-size: 0.8rem;
      color: #555;
    }
  </style>
</head>
<body>

  <div class="card">
    <h1>Log temperatury z QR</h1>
    <div class="info-row small">
      Dane są przesyłane w formacie binarnym.
      Aktualnie QR zawiera T1 w równych odstępach czasu (np. co 15 minut).
      Miejsce na T2 jest przygotowane na przyszłość.
    </div>
  </div>

  <div class="card">
    <h2>Źródło danych</h2>
    <div class="controls">
      <input id="hashInput" type="text" placeholder="#b=...&r=..." />
      <button id="btnLoadHash">Załaduj z pola</button>
    </div>
    <div class="small">
      Zwykle nie trzeba nic wpisywać – po zeskanowaniu QR telefon sam otwiera adres
      z fragmentem <code>#b=...</code>. Ten adres można skopiować tutaj, jeśli trzeba.
    </div>
    <div id="errorBox" class="error" style="display:none;"></div>
  </div>

  <div class="card">
    <h2>Informacje o logu</h2>
    <div class="info-row"><span class="info-label">Data:</span> <span id="infoDate">–</span></div>
    <div class="info-row"><span class="info-label">Rejestracja:</span> <span id="infoRej">–</span></div>
    <div class="info-row"><span class="info-label">Interwał logu:</span> <span id="infoInterval">–</span></div>
    <div class="info-row"><span class="info-label">Próbek w QR:</span> <span id="infoSamples">–</span></div>
  </div>

  <div class="card">
    <h2>Tabela temperatur</h2>
    <div id="tableContainer">
      Brak danych – zeskanuj QR lub wklej adres z fragmentem <code>#b=...</code>.
    </div>
  </div>

<script>
  function showError(msg) {
    const box = document.getElementById('errorBox');
    box.textContent = msg;
    box.style.display = msg ? 'block' : 'none';
  }

  function clearInfo() {
    document.getElementById('infoDate').textContent = '–';
    document.getElementById('infoRej').textContent = '–';
    document.getElementById('infoInterval').textContent = '–';
    document.getElementById('infoSamples').textContent = '–';
    document.getElementById('tableContainer').innerHTML =
      'Brak danych – zeskanuj QR lub wklej adres z fragmentem <code>#b=...</code>.';
  }

  function getParamFromHash(rawHash, key) {
    if (!rawHash) return null;
    let h = rawHash;
    if (h.startsWith('#')) h = h.substring(1);
    if (!h) return null;

    const parts = h.split('&');
    for (const part of parts) {
      const [k, v] = part.split('=');
      if (k === key) {
        return v ? decodeURIComponent(v) : '';
      }
    }
    return null;
  }

  function getBParamFromHash(rawHash) {
    return getParamFromHash(rawHash, 'b');
  }

  function getRParamFromHash(rawHash) {
    return getParamFromHash(rawHash, 'r');
  }

  function base64ToBytes(b64) {
    const binStr = atob(b64);
    const len = binStr.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      bytes[i] = binStr.charCodeAt(i) & 0xFF;
    }
    return bytes;
  }

  // Dekoder payloadu:
  //  [0] = rok-2000
  //  [1] = miesiac
  //  [2] = dzien
  //  [3] = interwal_min
  //  dalej:
  //   - wariant 1 (obecny):  slotsPerDay bajtow T1
  //   - wariant 2 (przyszly): slotsPerDay T1 + slotsPerDay T2
  function decodePayload(bytes) {
    if (!bytes || bytes.length < 5) {
      throw new Error('Za mało danych (nagłówek + przynajmniej 1 slot).');
    }

    const yearOff    = bytes[0];
    const year       = 2000 + yearOff;
    const month      = bytes[1];
    const day        = bytes[2];
    const intervalMin = bytes[3];

    if (intervalMin === 0) {
      throw new Error('Interwał = 0 w nagłówku.');
    }
    if (1440 % intervalMin !== 0) {
      throw new Error('Interwał z nagłówka nie dzieli 1440.');
    }

    const slotsPerDay = 1440 / intervalMin;
    const dataOffset  = 4;
    const remain      = bytes.length - dataOffset;

    if (remain < slotsPerDay) {
      throw new Error('Za mało danych w payloadzie (mniej niż slotsPerDay).');
    }

    // Czy mamy również T2?
    const hasT2 = (remain >= 2 * slotsPerDay);
    const samples = [];

    for (let i = 0; i < slotsPerDay; i++) {
      const encT1 = bytes[dataOffset + i];
      let encT2 = 0xFF;
      if (hasT2) {
        encT2 = bytes[dataOffset + slotsPerDay + i];
      }

      // obliczamy czas slotu
      const minutesFromMidnight = i * intervalMin;
      const hour   = Math.floor(minutesFromMidnight / 60);
      const minute = minutesFromMidnight % 60;

      // brak jakichkolwiek danych w slocie
      if (encT1 === 0xFF && encT2 === 0xFF) {
        continue;
      }

      let t1 = null;
      let t2 = null;

      if (encT1 !== 0xFF) {
        t1 = encT1 - 40;
      }
      if (encT2 !== 0xFF) {
        t2 = encT2 - 40;
      }

      samples.push({ hour, minute, t1, t2 });
    }

    samples.sort((a, b) => {
      const ta = a.hour * 60 + a.minute;
      const tb = b.hour * 60 + b.minute;
      return ta - tb;
    });

    return {
      year,
      month,
      day,
      intervalMin,
      samples
    };
  }

  function pad2(n) {
    return n < 10 ? '0' + n : '' + n;
  }

  function renderData(data) {
    const dateStr = pad2(data.day) + '.' + pad2(data.month) + '.' + data.year;
    document.getElementById('infoDate').textContent = dateStr;
    document.getElementById('infoInterval').textContent = data.intervalMin + ' min';
    document.getElementById('infoSamples').textContent = data.samples.length;

    if (!data.samples.length) {
      document.getElementById('tableContainer').innerHTML = 'Brak próbek w danych QR.';
      return;
    }

    let html = '<table><thead><tr>' +
      '<th>Lp</th><th>Czas</th><th>T1 [°C]</th><th>T2 [°C]</th>' +
      '</tr></thead><tbody>';

    data.samples.forEach((s, idx) => {
      const timeStr = pad2(s.hour) + ':' + pad2(s.minute);
      const t1Str = (s.t1 === null || s.t1 === undefined) ? '–' : s.t1;
      const t2Str = (s.t2 === null || s.t2 === undefined) ? '–' : s.t2; // miejsce na druga czujke

      html += '<tr>' +
        '<td>' + (idx + 1) + '</td>' +
        '<td>' + timeStr + '</td>' +
        '<td>' + t1Str + '</td>' +
        '<td>' + t2Str + '</td>' +
        '</tr>';
    });

    html += '</tbody></table>';
    document.getElementById('tableContainer').innerHTML = html;
  }

  function processFromHash(hash) {
    showError('');
    clearInfo();

    const bParam = getBParamFromHash(hash);
    if (!bParam) {
      showError('Nie znaleziono parametru b=... w adresie (hash).');
      return;
    }

    const rParam = getRParamFromHash(hash);
    if (rParam) {
      document.getElementById('infoRej').textContent = rParam;
    }

    try {
      const bytes = base64ToBytes(bParam);
      const data = decodePayload(bytes);
      renderData(data);
    } catch (e) {
      console.error(e);
      showError('Błąd dekodowania: ' + e.message);
    }
  }

  window.addEventListener('DOMContentLoaded', () => {
    const currentHash = window.location.hash || '';
    const hashInput = document.getElementById('hashInput');

    if (currentHash) {
      hashInput.value = currentHash;
      processFromHash(currentHash);
    }

    document.getElementById('btnLoadHash').addEventListener('click', () => {
      let h = hashInput.value.trim();
      if (!h) {
        showError('Wklej fragment w postaci "#b=..." lub "#b=...&r=...".');
        return;
      }
      if (!h.startsWith('#')) {
        h = '#' + h;
      }
      processFromHash(h);
    });
  });
</script>

</body>
</html>
