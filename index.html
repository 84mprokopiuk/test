<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <title>Log temperatury z QR</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 20px;
      background: #f5f5f5;
    }
    h1 {
      font-size: 1.4rem;
      margin-bottom: 0.3rem;
    }
    h2 {
      font-size: 1.1rem;
      margin-top: 1.2rem;
    }
    .card {
      background: #ffffff;
      border-radius: 8px;
      padding: 16px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.08);
      margin-bottom: 16px;
    }
    .info-row {
      margin: 4px 0;
    }
    .info-label {
      font-weight: 600;
    }
    .error {
      color: #b00020;
      font-weight: 600;
      margin-top: 8px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 8px;
      background: #fff;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 6px 8px;
      text-align: center;
      font-size: 0.9rem;
    }
    th {
      background: #f0f0f0;
      font-weight: 600;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      margin-top: 8px;
    }
    .controls input[type="text"] {
      flex: 1 1 260px;
      padding: 6px 8px;
      border-radius: 4px;
      border: 1px solid #ccc;
      font-family: monospace;
      font-size: 0.85rem;
    }
    button {
      padding: 6px 12px;
      border-radius: 4px;
      border: none;
      background: #1976d2;
      color: white;
      cursor: pointer;
      font-size: 0.9rem;
    }
    button:hover {
      background: #125ca4;
    }
    .small {
      font-size: 0.8rem;
      color: #555;
    }
  </style>
</head>
<body>

  <div class="card">
    <h1>Log temperatury z QR</h1>
    <div class="info-row small">
      Dane w QR zawierają punkty bazowe (co 1&nbsp;h) i wybrane punkty alarmowe.
      Tabela poniżej pokazuje przebieg co 15&nbsp;min.
    </div>
  </div>

  <div class="card">
    <h2>Źródło danych</h2>
    <div class="controls">
      <input id="hashInput" type="text" placeholder="#b=..." />
      <button id="btnLoadHash">Załaduj z pola</button>
    </div>
    <div class="small">
      Zwykle nie trzeba nic wpisywać – po zeskanowaniu QR telefon sam otwiera adres
      z fragmentem <code>#b=...</code>. Ten adres można skopiować tutaj, jeśli trzeba.
    </div>
    <div id="errorBox" class="error" style="display:none;"></div>
  </div>

  <div class="card">
    <h2>Informacje o logu</h2>
    <div class="info-row"><span class="info-label">Data:</span> <span id="infoDate">–</span></div>
    <div class="info-row"><span class="info-label">Rejestracja:</span> <span id="infoRej">–</span></div>
    <div class="info-row"><span class="info-label">Interwał logu:</span> <span id="infoInterval">–</span></div>
    <div class="info-row"><span class="info-label">Próbek w QR (baza+alarmy):</span> <span id="infoSamples">–</span></div>
  </div>

  <div class="card">
    <h2>Tabela temperatur (co 15 min)</h2>
    <div id="tableContainer">
      Brak danych – zeskanuj QR lub wklej adres z fragmentem <code>#b=...</code>.
    </div>
  </div>

<script>
  function showError(msg) {
    const box = document.getElementById('errorBox');
    box.textContent = msg;
    box.style.display = msg ? 'block' : 'none';
  }

  function clearInfo() {
    document.getElementById('infoDate').textContent = '–';
    document.getElementById('infoRej').textContent = '–';
    document.getElementById('infoInterval').textContent = '–';
    document.getElementById('infoSamples').textContent = '–';
    document.getElementById('tableContainer').innerHTML =
      'Brak danych – zeskanuj QR lub wklej adres z fragmentem <code>#b=...</code>.';
  }

  function getBParamFromHash(rawHash) {
    if (!rawHash) return null;
    let h = rawHash;
    if (h.startsWith('#')) h = h.substring(1);
    if (!h) return null;

    const parts = h.split('&');
    for (const part of parts) {
      const [k, v] = part.split('=');
      if (k === 'b') {
        return v ? decodeURIComponent(v) : '';
      }
    }
    return null;
  }

  function getRParamFromHash(rawHash) {
    if (!rawHash) return null;
    let h = rawHash;
    if (h.startsWith('#')) h = h.substring(1);
    if (!h) return null;

    const parts = h.split('&');
    for (const part of parts) {
      const [k, v] = part.split('=');
      if (k === 'r') {
        return v ? decodeURIComponent(v) : '';
      }
    }
    return null;
  }

  function base64ToBytes(b64) {
    const binStr = atob(b64);
    const len = binStr.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      bytes[i] = binStr.charCodeAt(i) & 0xFF;
    }
    return bytes;
  }

  // Dekoduje payload z ESP:
  // [0] = rok-2000, [1] = miesiac, [2] = dzien, [3] = interwal (np. 15)
  // dalej powtarza sie: [slot][T1enc][T2enc]
  function decodePayload(bytes) {
    if (!bytes || bytes.length < 4) {
      throw new Error('Za mało danych (nagłówek krótszy niż 4 bajty).');
    }

    const yearOff    = bytes[0];
    const year       = 2000 + yearOff;
    const month      = bytes[1];
    const day        = bytes[2];
    const intervalMin = bytes[3];

    if (intervalMin === 0) {
      throw new Error('Interwał = 0 w nagłówku.');
    }
    if (60 % intervalMin !== 0 || 1440 % intervalMin !== 0) {
      throw new Error('Interwał z nagłówka nie dzieli 60/1440.');
    }

    const slotsPerHour = 60 / intervalMin;
    const totalSlotsPerDay = 1440 / intervalMin;

    const samples = [];

    let i = 4;
    while (i + 2 < bytes.length) {
      const slot  = bytes[i++];
      const t1Enc = bytes[i++];
      const t2Enc = bytes[i++];

      if (slot >= totalSlotsPerDay) {
        continue;
      }

      const hour   = Math.floor(slot / slotsPerHour);
      const within = slot % slotsPerHour;
      const minute = within * intervalMin;

      const t1 = t1Enc - 40;
      const t2 = t2Enc - 40;

      samples.push({ slot, hour, minute, t1, t2 });
    }

    // sort po slocie (czas rosnąco)
    samples.sort((a, b) => a.slot - b.slot);

    return {
      year,
      month,
      day,
      intervalMin,
      samples,
      totalSlotsPerDay
    };
  }

  function pad2(n) {
    return n < 10 ? '0' + n : '' + n;
  }

  // Buduje pełną siatkę co intervalMin (np. 96 punktów dla 15 min)
  // z interpolacją liniową między próbkami z QR (ukrytą).
  function buildFullGrid(data) {
    const interval = data.intervalMin;
    const totalSlots = data.totalSlotsPerDay;
    const realBySlot = new Array(totalSlots).fill(null);

    // wrzucamy realne próbki (bazowe + alarmowe) do tablicy wg slotu
    data.samples.forEach(s => {
      if (s.slot >= 0 && s.slot < totalSlots) {
        realBySlot[s.slot] = { t1: s.t1, t2: s.t2 };
      }
    });

    // tablica poprzednich i następnych realnych slotów
    const prevIdx = new Array(totalSlots).fill(-1);
    const nextIdx = new Array(totalSlots).fill(-1);

    let last = -1;
    for (let i = 0; i < totalSlots; ++i) {
      if (realBySlot[i]) last = i;
      prevIdx[i] = last;
    }

    last = -1;
    for (let i = totalSlots - 1; i >= 0; --i) {
      if (realBySlot[i]) last = i;
      nextIdx[i] = last;
    }

    const grid = [];

    for (let slot = 0; slot < totalSlots; ++slot) {
      const totalMinutes = slot * interval;
      const hour = Math.floor(totalMinutes / 60);
      const minute = totalMinutes % 60;

      let t1, t2;

      if (realBySlot[slot]) {
        // realny punkt z QR
        t1 = realBySlot[slot].t1;
        t2 = realBySlot[slot].t2;
      } else {
        const p = prevIdx[slot];
        const n = nextIdx[slot];

        if (p === -1 && n === -1) {
          // brak jakichkolwiek danych – teoretycznie nie powinno sie zdarzyc
          continue;
        } else if (p === -1) {
          // tylko następny – kopiujemy
          t1 = realBySlot[n].t1;
          t2 = realBySlot[n].t2;
        } else if (n === -1) {
          // tylko poprzedni – kopiujemy
          t1 = realBySlot[p].t1;
          t2 = realBySlot[p].t2;
        } else {
          // interpolacja liniowa
          const span = n - p;
          const pos  = slot - p;
          const w    = span === 0 ? 0 : (pos / span);

          const t1p = realBySlot[p].t1;
          const t1n = realBySlot[n].t1;
          const t2p = realBySlot[p].t2;
          const t2n = realBySlot[n].t2;

          t1 = t1p + (t1n - t1p) * w;
          t2 = t2p + (t2n - t2p) * w;
        }
      }

      grid.push({
        slot,
        hour,
        minute,
        t1,
        t2
      });
    }

    return grid;
  }

  function renderData(data) {
    const dateStr = pad2(data.day) + '.' + pad2(data.month) + '.' + data.year;
    document.getElementById('infoDate').textContent = dateStr;
    document.getElementById('infoInterval').textContent = data.intervalMin + ' min';
    document.getElementById('infoSamples').textContent = data.samples.length;

    const grid = buildFullGrid(data);

    if (!grid.length) {
      document.getElementById('tableContainer').innerHTML = 'Brak próbek w danych QR.';
      return;
    }

    let html = '<table><thead><tr>' +
      '<th>Lp</th><th>Czas</th><th>T1 [°C]</th><th>T2 [°C]</th>' +
      '</tr></thead><tbody>';

    grid.forEach((row, idx) => {
      const timeStr = pad2(row.hour) + ':' + pad2(row.minute);
      const t1Str = (row.t1 !== null && row.t1 !== undefined) ? row.t1.toFixed(1) : '–';
      const t2Str = (row.t2 !== null && row.t2 !== undefined) ? row.t2.toFixed(1) : '–';

      html += '<tr>' +
        '<td>' + (idx + 1) + '</td>' +
        '<td>' + timeStr + '</td>' +
        '<td>' + t1Str + '</td>' +
        '<td>' + t2Str + '</td>' +
        '</tr>';
    });

    html += '</tbody></table>';
    document.getElementById('tableContainer').innerHTML = html;
  }

  function processFromHash(hash) {
    showError('');
    clearInfo();

    const bParam = getBParamFromHash(hash);
    if (!bParam) {
      showError('Nie znaleziono parametru b=... w adresie (hash).');
      return;
    }

    const rParam = getRParamFromHash(hash);
    if (rParam) {
      document.getElementById('infoRej').textContent = rParam;
    }

    try {
      const bytes = base64ToBytes(bParam);
      const data = decodePayload(bytes);
      renderData(data);
    } catch (e) {
      console.error(e);
      showError('Błąd dekodowania: ' + e.message);
    }
  }

  window.addEventListener('DOMContentLoaded', () => {
    const currentHash = window.location.hash || '';
    const hashInput = document.getElementById('hashInput');

    if (currentHash) {
      hashInput.value = currentHash;
      processFromHash(currentHash);
    }

    document.getElementById('btnLoadHash').addEventListener('click', () => {
      let h = hashInput.value.trim();
      if (!h) {
        showError('Wklej fragment w postaci "#b=..." lub "#b=...&r=...".');
        return;
      }
      if (!h.startsWith('#')) {
        h = '#' + h;
      }
      processFromHash(h);
    });
  });
</script>

</body>
</html>
